name: .Terraform Deployer

on:
  workflow_call:
    inputs:
      mode:
        description: "Execution mode: initial-setup (deploy-terraform.sh) or infra-ai-hub (direct terraform)"
        required: true
        type: string

      environment_name:
        description: "The name of the environment to deploy to"
        required: true
        type: string

      command:
        description: "The Terraform command to run (init, plan, apply, destroy)"
        required: true
        type: string
        default: "apply"

      # initial-setup mode inputs
      target_module:
        description: "Module to target (e.g., bastion, network, azure_proxy). Required for initial-setup mode."
        required: false
        type: string

      azure_proxy_image:
        description: "Container image for azure-proxy (e.g., ghcr.io/org/repo/azure-proxy/chisel:latest)"
        required: false
        type: string
        default: ""

      # infra-ai-hub mode inputs
      working_directory:
        description: "Working directory for direct Terraform mode (e.g., ./infra-ai-hub)"
        required: false
        type: string

      backend_key:
        description: "Terraform backend key (e.g., ai-hub/dev/terraform.tfstate)"
        required: false
        type: string

      variable_file:
        description: "Optional var-file to use (e.g., terraform.tfvars)"
        required: false
        type: string

      # Secure tunnel support
      use_secure_tunnel:
        description: "Whether to run Terraform behind a local HTTP proxy via chisel+privoxy"
        required: false
        type: boolean
        default: false

      proxy_url:
        description: "Proxy URL for chisel client (required if use_secure_tunnel=true)"
        required: false
        type: string

      proxy_auth:
        description: "Proxy auth token for chisel client (required if use_secure_tunnel=true)"
        required: false
        type: string

      # Common configuration
      app_name:
        description: "App name prefix"
        required: false
        type: string
        default: "ai-hub"

      location:
        description: "Azure region"
        required: false
        type: string
        default: "Canada Central"
    outputs:
      proxy_url:
        description: "The proxy URL output from initial-setup (if applicable)"
        value: ${{ jobs.terraform.outputs.proxy_url || '' }}
      proxy_auth:
        description: "The proxy auth output from initial-setup (if applicable)"
        value: ${{ jobs.terraform.outputs.proxy_auth || '' }}
    secrets:
      AZURE_CLIENT_ID:
        required: true
      AZURE_TENANT_ID:
        required: true
      AZURE_SUBSCRIPTION_ID:
        required: true

      # Common network/environment secrets (optional depending on mode)
      VNET_NAME:
        required: false
      VNET_RESOURCE_GROUP_NAME:
        required: false
      VNET_ADDRESS_SPACE:
        required: false

      DEV_ADDRESS_SPACES:
        required: false
      TEST_ADDRESS_SPACES:
        required: false
      PROD_ADDRESS_SPACES:
        required: false

      TARGET_VNET_ADDRESS_SPACES:
        required: false
      SOURCE_VNET_ADDRESS_SPACE:
        required: false

permissions:
  id-token: write
  contents: read

env:
  TF_VERSION: 1.14.3
  TF_LOG: ERROR
  CHISEL_IMAGE_VERSION: 1.11
  CHISEL_IMAGE: jpillora/chisel

jobs:
  terraform:
    name: Terraform ${{ inputs.command }} (${{ inputs.mode }})
    if: ${{ !(inputs.mode == 'initial-setup' && inputs.target_module == 'jumpbox') }}
    runs-on: ubuntu-24.04
    environment: ${{ inputs.environment_name }}
    outputs:
      proxy_url: ${{ steps.tools.outputs.proxy_url }}
      proxy_auth: ${{ steps.tools.outputs.proxy_auth }}
    env:
      CI: "true"
      ARM_USE_OIDC: "true"

      # Common Terraform variables
      TF_VAR_app_name: ${{ inputs.app_name }}
      TF_VAR_app_env: ${{ inputs.environment_name }}
      TF_VAR_location: ${{ inputs.location }}
      TF_VAR_resource_group_name: ${{ format('{0}-{1}', inputs.app_name, inputs.environment_name) }}
      TF_VAR_common_tags: >-
        {"environment":"${{ inputs.environment_name }}","app_env":"${{ inputs.environment_name }}","repo_name":"${{ github.event.repository.name }}"}

      TF_VAR_subscription_id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      TF_VAR_tenant_id: ${{ secrets.AZURE_TENANT_ID }}
      TF_VAR_client_id: ${{ secrets.AZURE_CLIENT_ID }}

      # Network-related variables (used by different modes)
      TF_VAR_vnet_name: ${{ secrets.VNET_NAME }}
      TF_VAR_vnet_resource_group_name: ${{ secrets.VNET_RESOURCE_GROUP_NAME }}
      TF_VAR_vnet_address_space: ${{ secrets.VNET_ADDRESS_SPACE }}

      TF_VAR_dev_address_spaces: ${{ secrets.DEV_ADDRESS_SPACES }}
      TF_VAR_test_address_spaces: ${{ secrets.TEST_ADDRESS_SPACES }}
      TF_VAR_prod_address_spaces: ${{ secrets.PROD_ADDRESS_SPACES }}

      TF_VAR_target_vnet_address_spaces: ${{ secrets.TARGET_VNET_ADDRESS_SPACES }}
      TF_VAR_source_vnet_address_space: ${{ secrets.SOURCE_VNET_ADDRESS_SPACE }}

      # Only used by infra-ai-hub, harmless if unset/unused
      TF_VAR_key_vault_name: ${{ format('{0}-{1}-{2}-kv', inputs.app_name, inputs.environment_name, vars.SUBSCRIPTION_NAME) }}

      # Secure tunnel proxy support
      HTTP_PROXY: ${{ inputs.use_secure_tunnel && 'http://127.0.0.1:8118' || '' }}
      HTTPS_PROXY: ${{ inputs.use_secure_tunnel && 'http://127.0.0.1:8118' || '' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run Secure Tunnel Client with http proxy in Docker
        if: inputs.use_secure_tunnel
        shell: bash
        env:
          PROXY_URL: ${{ inputs.proxy_url }}
          PROXY_AUTH: ${{ inputs.proxy_auth }}
        run: |
          set -euo pipefail

          if [[ -z "${PROXY_URL}" || -z "${PROXY_AUTH}" ]]; then
            echo "proxy_url and proxy_auth are required when use_secure_tunnel=true" >&2
            exit 1
          fi

          docker network create proxy-net >/dev/null 2>&1 || true
          docker run -d --name chisel-client --network proxy-net ${CHISEL_IMAGE}:${CHISEL_IMAGE_VERSION} client --auth "$PROXY_AUTH" "$PROXY_URL" 0.0.0.0:1080:socks
          docker run -d --name privoxy --network proxy-net -p 127.0.0.1:8118:8118 -e SOCKS_HOST=chisel-client -e SOCKS_PORT=1080 ghcr.io/${{ github.repository }}/azure-proxy/privoxy:latest

      - name: Azure CLI Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@b9cd54a3c349d3f38e8881555d616ced269862dd # v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Run initial-setup Terraform via deploy-terraform.sh
        id: tools
        if: inputs.mode == 'initial-setup'
        shell: bash
        working-directory: ./initial-setup/infra
        env:
          TF_VAR_azure_proxy_image: ${{ inputs.azure_proxy_image }}
          TF_VAR_enable_azure_proxy: true
        run: |
          set -euo pipefail

          if [[ -z "${{ inputs.target_module }}" ]]; then
            echo "target_module is required for initial-setup mode" >&2
            exit 1
          fi
          if [[ "${{ inputs.target_module }}" == "jumpbox" ]]; then
            echo "jumpbox is not a valid target_module" >&2
            exit 1
          fi

          chmod +x ./deploy-terraform.sh
          ./deploy-terraform.sh "${{ inputs.command }}" -target=module."${{ inputs.target_module }}"
          PROXY_URL_OUTPUT=$(terraform output -raw proxy_url || echo "")
          PROXY_AUTH_OUTPUT=$(terraform output -raw proxy_auth || echo "")
          # add masking to outputs to avoid being exposed in logs
          if [[ -n "$PROXY_URL_OUTPUT" ]]; then
            echo "::add-mask::$PROXY_URL_OUTPUT"
            echo "proxy_url=$PROXY_URL_OUTPUT" >> $GITHUB_OUTPUT
          fi
          if [[ -n "$PROXY_AUTH_OUTPUT" ]]; then
            echo "::add-mask::$PROXY_AUTH_OUTPUT"
            echo "proxy_auth=$PROXY_AUTH_OUTPUT" >> $GITHUB_OUTPUT
          fi

      - name: Run Terraform directly (infra-ai-hub)
        if: inputs.mode == 'infra-ai-hub'
        shell: bash
        working-directory: ${{ inputs.working_directory }}
        run: |
          set -euo pipefail

          if [[ -z "${{ inputs.working_directory }}" ]]; then
            echo "working_directory is required for infra-ai-hub mode" >&2
            exit 1
          fi
          if [[ -z "${{ inputs.backend_key }}" ]]; then
            echo "backend_key is required for infra-ai-hub mode" >&2
            exit 1
          fi

          var_file_args=()
          if [[ -n "${{ inputs.variable_file }}" ]]; then
            var_file_args+=("-var-file=${{ inputs.variable_file }}")
          fi

          terraform init -upgrade -reconfigure \
            -backend-config="resource_group_name=${{ secrets.VNET_RESOURCE_GROUP_NAME }}" \
            -backend-config="storage_account_name=${{ vars.STORAGE_ACCOUNT_NAME }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=${{ inputs.backend_key }}" \
            -backend-config="subscription_id=${{ secrets.AZURE_SUBSCRIPTION_ID }}" \
            -backend-config="tenant_id=${{ secrets.AZURE_TENANT_ID }}" \
            -backend-config="client_id=${{ secrets.AZURE_CLIENT_ID }}" \
            -backend-config="use_oidc=true"

          case "${{ inputs.command }}" in
            apply|destroy)
              terraform "${{ inputs.command }}" -auto-approve -input=false "${var_file_args[@]}"
              ;;
            plan)
              terraform plan -input=false "${var_file_args[@]}"
              ;;
            *)
              terraform "${{ inputs.command }}" -input=false "${var_file_args[@]}"
              ;;
          esac
