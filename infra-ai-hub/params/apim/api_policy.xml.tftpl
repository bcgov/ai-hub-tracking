<policies>
    <inbound>
        <base />
%{ if tracking_dimensions_enabled ~}
        <!-- Extract tracking dimensions from headers -->
        <include-fragment fragment-id="tracking-dimensions" />
%{ endif ~}
        <!-- Tenant identification -->
        <set-header name="X-Tenant-Id" exists-action="override">
            <value>${tenant_name}</value>
        </set-header>
%{ if rate_limiting_enabled && length(model_deployments) > 0 ~}

        <!-- Per-model token rate limiting based on tenant.tfvars model_deployments capacity -->
        <!-- Each model has its own rate limit matching its Azure OpenAI deployment capacity -->
        <!-- Extracts deployment name from URL: /openai/deployments/{deployment-name}/... -->
        <set-variable name="deploymentName" value="@{
            var path = context.Request.Url.Path;
            var match = System.Text.RegularExpressions.Regex.Match(path, @&quot;/deployments/([^/]+)/&quot;);
            return match.Success ? match.Groups[1].Value : &quot;unknown&quot;;
        }" />
        <choose>
%{ for model in model_deployments ~}
            <when condition="@(context.Variables.GetValueOrDefault&lt;string&gt;(&quot;deploymentName&quot;, &quot;&quot;) == &quot;${model.name}&quot;)">
                <!-- Rate limit for ${model.name}: ${model.capacity}k TPM (deployment capacity is in thousands of TPM) -->
                <llm-token-limit
                    counter-key="@(context.Subscription.Id + &quot;-${model.name}&quot;)"
                    tokens-per-minute="${model.capacity * 1000}"
                    estimate-prompt-tokens="true"
                    remaining-tokens-variable-name="remainingTokens"
                    remaining-tokens-header-name="x-ratelimit-remaining-tokens"
                    tokens-consumed-variable-name="tokensConsumed" />
            </when>
%{ endfor ~}
            <otherwise>
                <!-- Fallback rate limit for unknown models: ${tokens_per_minute} TPM -->
                <llm-token-limit
                    counter-key="@(context.Subscription.Id + &quot;-unknown&quot;)"
                    tokens-per-minute="${tokens_per_minute}"
                    estimate-prompt-tokens="true"
                    remaining-tokens-variable-name="remainingTokens"
                    remaining-tokens-header-name="x-ratelimit-remaining-tokens"
                    tokens-consumed-variable-name="tokensConsumed" />
            </otherwise>
        </choose>
%{ endif ~}
%{ if rate_limiting_enabled && length(model_deployments) == 0 ~}

        <!-- Token rate limiting: ${tokens_per_minute} TPM per subscription for this tenant -->
        <!-- Protects backend from token exhaustion, returns 429 when exceeded -->
        <llm-token-limit
            counter-key="@(context.Subscription.Id)"
            tokens-per-minute="${tokens_per_minute}"
            estimate-prompt-tokens="true"
            remaining-tokens-variable-name="remainingTokens"
            remaining-tokens-header-name="x-ratelimit-remaining-tokens"
            tokens-consumed-variable-name="tokensConsumed" />
%{ endif ~}

        <!-- Path-based routing to appropriate backend service -->
        <choose>
%{ if document_intelligence_enabled ~}
            <!-- Document Intelligence requests: match documentintelligence, formrecognizer, or documentModels in path -->
            <when condition="@(context.Request.Url.Path.ToLower().Contains(&quot;documentintelligence&quot;) || context.Request.Url.Path.ToLower().Contains(&quot;formrecognizer&quot;) || context.Request.Url.Path.ToLower().Contains(&quot;documentmodels&quot;))">
                <set-backend-service backend-id="${tenant_name}-docint" />
                <authentication-managed-identity resource="https://cognitiveservices.azure.com" output-token-variable-name="msi-access-token" ignore-error="false" />
                <set-header name="Authorization" exists-action="override">
                    <value>@("Bearer " + (string)context.Variables["msi-access-token"])</value>
                </set-header>
                <set-header name="api-key" exists-action="delete" />
            </when>
%{ endif ~}
%{ if openai_enabled ~}
            <!-- OpenAI/AI Foundry requests: /openai/* -->
            <!-- Routes to shared AI Foundry Hub - tenant model deployments are on the Hub -->
            <!-- Deployment names on Hub are prefixed with tenant name (e.g., wlrs-gpt-4.1-mini) -->
            <when condition="@(context.Request.Url.Path.ToLower().Contains(&quot;openai&quot;))">
                <set-backend-service backend-id="${tenant_name}-openai" />
                <!-- Rewrite deployment name in URL to include tenant prefix -->
                <!-- Client sends: /openai/deployments/gpt-4.1-mini/chat/completions -->
                <!-- Backend receives: /openai/deployments/{tenant}-gpt-4.1-mini/chat/completions -->
                <set-variable name="rewrittenPath" value="@{
                    var path = context.Request.Url.Path;
                    // Handle both with and without leading slash
                    var match = System.Text.RegularExpressions.Regex.Match(path, @&quot;/?openai/deployments/([^/]+)/(.*)&quot;);
                    if (match.Success) {
                        var deploymentName = match.Groups[1].Value;
                        var rest = match.Groups[2].Value;
                        return &quot;/openai/deployments/${tenant_name}-&quot; + deploymentName + &quot;/&quot; + rest;
                    }
                    return &quot;/&quot; + path;
                }" />
                <rewrite-uri template="@((string)context.Variables[&quot;rewrittenPath&quot;])" copy-unmatched-params="true" />
                <!-- Initialize isStream to false, will be updated at runtime -->
                <set-variable name="isStream" value="@(false)" />
%{ if pii_redaction_enabled ~}
                <!-- PII Anonymization via Azure Language Service -->
                <set-variable name="piiAnonymizationEnabled" value="true" />
                <set-variable name="piiInputContent" value="@(context.Request.Body.As&lt;string&gt;(preserveContent: true))" />
                <!-- PII Configuration: excluded categories and structural preservation -->
                <set-variable name="piiExcludedCategories" value="${jsonencode(pii_excluded_categories)}" />
                <set-variable name="piiPreserveJsonStructure" value="${pii_preserve_json_structure}" />
                <set-variable name="piiStructuralWhitelist" value="${jsonencode(pii_structural_whitelist)}" />
                <set-variable name="piiDetectionLanguage" value="${pii_detection_language}" />
                <!-- PII Fail-closed: block request if redaction fails (default: false = fail-open) -->
                <set-variable name="piiFailClosed" value="${pii_fail_closed}" />
                <include-fragment fragment-id="pii-anonymization" />
                <!-- Apply the anonymized content back to the request body -->
                <set-body>@((string)context.Variables["piiAnonymizedContent"])</set-body>
%{ endif ~}
                <authentication-managed-identity resource="https://cognitiveservices.azure.com" output-token-variable-name="msi-access-token" ignore-error="false" />
                <set-header name="Authorization" exists-action="override">
                    <value>@("Bearer " + (string)context.Variables["msi-access-token"])</value>
                </set-header>
                <set-header name="api-key" exists-action="delete" />
            </when>
%{ endif ~}
%{ if speech_services_enabled ~}
            <!-- Speech Services requests: TTS and STT via custom subdomain -->
            <!-- Custom subdomain endpoints require service-specific path prefixes (/tts/, /stt/) -->
            <!-- Routes: /cognitiveservices/voices/list, /cognitiveservices/v1, speech/synthesis, speech/recognition -->
            <when condition="@(context.Request.Url.Path.ToLower().Contains(&quot;cognitiveservices/voices&quot;) || context.Request.Url.Path.ToLower().Contains(&quot;cognitiveservices/v1&quot;) || context.Request.Url.Path.ToLower().Contains(&quot;speech/synthesis&quot;) || context.Request.Url.Path.ToLower().Contains(&quot;speech/recognition&quot;))">
                <!-- Determine backend (TTS or STT) and path prefix based on request path -->
                <set-variable name="speechBackendId" value="@{
                    var pathLower = context.Request.Url.Path.ToLower();
                    if (pathLower.Contains(&quot;speech/recognition&quot;) || pathLower.Contains(&quot;/stt/&quot;)) {
                        return &quot;${tenant_name}-speech-stt&quot;;
                    }
                    return &quot;${tenant_name}-speech-tts&quot;;
                }" />
                <set-backend-service backend-id="@((string)context.Variables[&quot;speechBackendId&quot;])" />
                <!-- Rewrite URI for custom subdomain: add /tts/ or /stt/ prefix -->
                <!-- TTS paths: /cognitiveservices/voices/list, /cognitiveservices/v1 (synthesis) -->
                <!-- STT paths: speech/recognition -->
                <set-variable name="rewrittenSpeechPath" value="@{
                    var path = context.Request.Url.Path;
                    var pathLower = path.ToLower();
                    
                    // Determine service prefix based on path
                    string servicePrefix;
                    if (pathLower.Contains(&quot;speech/recognition&quot;) || pathLower.Contains(&quot;/stt/&quot;)) {
                        servicePrefix = &quot;/stt/&quot;;
                    } else {
                        servicePrefix = &quot;/tts/&quot;;  // TTS for voices list and synthesis
                    }
                    
                    // Add prefix to path only if it doesn't already start with it
                    if (pathLower.StartsWith(servicePrefix)) {
                        return path;
                    }
                    return servicePrefix + path.TrimStart('/');
                }" />
                <rewrite-uri template="@((string)context.Variables[&quot;rewrittenSpeechPath&quot;])" copy-unmatched-params="true" />
                <!-- Backend has credentials configured - remove any incoming api-key/auth -->
                <set-header name="Authorization" exists-action="delete" />
                <set-header name="api-key" exists-action="delete" />
            </when>
%{ endif ~}
%{ if ai_search_enabled ~}
            <!-- AI Search requests: /ai-search/* -->
            <when condition="@(context.Request.Url.Path.ToLower().Contains(&quot;ai-search&quot;))">
                <set-backend-service backend-id="${tenant_name}-ai-search" />
                <!-- Strip /ai-search prefix from path before forwarding to backend -->
                <rewrite-uri template="@{
                    var path = context.Request.Url.Path;
                    var searchIndex = path.ToLower().IndexOf(&quot;ai-search&quot;);
                    if (searchIndex >= 0) {
                        return &quot;/&quot; + path.Substring(searchIndex + 9).TrimStart('/');
                    }
                    return path;
                }" copy-unmatched-params="true" />
                <authentication-managed-identity resource="https://search.azure.com" output-token-variable-name="msi-access-token" ignore-error="false" />
                <set-header name="Authorization" exists-action="override">
                    <value>@("Bearer " + (string)context.Variables["msi-access-token"])</value>
                </set-header>
                <set-header name="api-key" exists-action="delete" />
            </when>
%{ endif ~}
%{ if storage_enabled ~}
            <!-- Storage requests: /storage/* -->
            <when condition="@(context.Request.Url.Path.ToLower().Contains(&quot;storage&quot;))">
                <set-backend-service backend-id="${tenant_name}-storage" />
                <authentication-managed-identity resource="https://storage.azure.com" output-token-variable-name="msi-access-token" ignore-error="false" />
                <set-header name="Authorization" exists-action="override">
                    <value>@("Bearer " + (string)context.Variables["msi-access-token"])</value>
                </set-header>
                <set-header name="api-key" exists-action="delete" />
            </when>
%{ endif ~}
            <!-- Default: Return 404 for unmatched paths -->
            <otherwise>
                <return-response>
                    <set-status code="404" reason="Not Found" />
                    <set-header name="Content-Type" exists-action="override">
                        <value>application/json</value>
                    </set-header>
                    <set-body>{"error":{"code":"NotFound","message":"The requested path is not supported by this API."}}</set-body>
                </return-response>
            </otherwise>
        </choose>
    </inbound>
    <backend>
        <!-- Selective buffering: buffer only OpenAI requests for PII redaction and token inspection -->
        <!-- Timeout with tenant-specific backend overrides, https://learn.microsoft.com/en-us/azure/api-management/forward-request-policy#attributes -->
        <choose>
            <when condition="@(context.Request.Url.Path.ToLower().Contains(&quot;openai&quot;))">
                <forward-request buffer-request-body="true" timeout="${backend_timeout_seconds}" />
            </when>
            <otherwise>
                <forward-request buffer-request-body="false" timeout="${backend_timeout_seconds}" />
            </otherwise>
        </choose>
    </backend>
    <outbound>
        <base />
%{ if document_intelligence_enabled ~}
        <!-- Rewrite Operation-Location header to use App Gateway URL instead of direct backend URL -->
        <!-- This is critical for async operations (202 responses) to ensure clients poll through App Gateway -->
        <!-- Uses X-Forwarded-Host header from App Gateway if present (original client hostname) -->
        <choose>
            <when condition="@(context.Response.Headers.ContainsKey(&quot;Operation-Location&quot;))">
                <set-header name="Operation-Location" exists-action="override">
                    <value>@{
                        var operationLocation = context.Response.Headers.GetValueOrDefault("Operation-Location", "");
                        if (!string.IsNullOrEmpty(operationLocation))
                        {
                            // Replace the direct backend URL with gateway URL
                            // Pattern: https://{backend}.cognitiveservices.azure.com/{path}
                            // Replace with: https://{gateway-host}/{tenant-api}/{path}
                            var backendPattern = new System.Text.RegularExpressions.Regex(@"https://[^/]+\.cognitiveservices\.azure\.com/");
                            
                            // Use X-Forwarded-Host if present (from App Gateway), otherwise fall back to OriginalUrl.Host (direct APIM)
                            var gatewayHost = context.Request.Headers.GetValueOrDefault("X-Forwarded-Host", context.Request.OriginalUrl.Host);
                            var gatewayUrl = context.Request.OriginalUrl.Scheme + "://" + gatewayHost + "/" + context.Api.Path.TrimStart('/') + "/";
                            return backendPattern.Replace(operationLocation, gatewayUrl);
                        }
                        return operationLocation;
                    }</value>
                </set-header>
            </when>
        </choose>
%{ endif ~}
%{ if openai_enabled && usage_logging_enabled ~}
        <!-- OpenAI usage logging -->
        <choose>
            <when condition="@(context.Request.Url.Path.ToLower().Contains(&quot;openai&quot;))">
                <set-variable name="responseBody" value="@(context.Response.Body.As&lt;JObject&gt;(preserveContent: true))" />
                <!-- Set routing metadata for usage logging (single-backend for now) -->
                <set-variable name="backendId" value="@(&quot;${tenant_name}-openai&quot;)" />
                <set-variable name="routeLocation" value="@(&quot;canadaeast&quot;)" />
                <set-variable name="routeName" value="@(&quot;primary&quot;)" />
                <set-variable name="deploymentName" value="@{
                    // Extract deployment name from URL path: /openai/deployments/{deployment-name}/...
                    var path = context.Request.Url.Path;
                    var match = System.Text.RegularExpressions.Regex.Match(path, @&quot;/deployments/([^/]+)/&quot;);
                    return match.Success ? match.Groups[1].Value : &quot;unknown&quot;;
                }" />
                <include-fragment fragment-id="openai-usage-logging" />
            </when>
        </choose>
%{ endif ~}
    </outbound>
    <on-error>
        <base />
    </on-error>
</policies>
