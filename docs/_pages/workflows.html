<!-- TITLE: GitHub Workflows -->
<!-- NAV: workflows -->

<h1>GitHub Actions Workflows</h1>

<p>This project uses GitHub Actions for automated infrastructure deployments with OIDC authentication to Azure.</p>

<h2>Workflow Overview</h2>

<table>
    <thead>
        <tr>
            <th>Workflow</th>
            <th>Trigger</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><strong>.builds.yml</strong></td>
            <td>Called by other workflows</td>
            <td>Reusable container build workflow for azure-proxy images</td>
        </tr>
        <tr>
            <td><strong>.deployer.yml</strong></td>
            <td>Called by other workflows</td>
            <td>Reusable Terraform deployer for <code>initial-setup/infra</code> (tools bootstrap and module-level operations)</td>
        </tr>
        <tr>
            <td><strong>.deployer-using-secure-tunnel.yml</strong></td>
            <td>Called by other workflows</td>
            <td>Reusable Terraform deployer for <code>infra-ai-hub</code> through Chisel + Privoxy secure tunnel</td>
        </tr>
        <tr>
            <td><strong>.lint.yml</strong></td>
            <td>Called by other workflows</td>
            <td>Reusable Terraform lint/format checks via pre-commit (<code>terraform fmt</code> + <code>tflint</code>)</td>
        </tr>
        <tr>
            <td><strong>add-or-remove-module.yml</strong></td>
            <td>Manual (workflow_dispatch)</td>
            <td>Deploy or destroy selected tools modules (bastion, azure_proxy, jumpbox, github_runners_aca)</td>
        </tr>
        <tr>
            <td><strong>manual-dispatch.yml</strong></td>
            <td>Manual (workflow_dispatch)</td>
            <td>Run <code>plan/apply/destroy</code> for dev/test/prod after provisioning proxy in tools</td>
        </tr>
        <tr>
            <td><strong>main-merge-test-deploy.yml</strong></td>
            <td>Push to <code>main</code></td>
            <td>Automatic post-merge deployment: applies latest infrastructure to test environment</td>
        </tr>
        <tr>
            <td><strong>pr-open.yml</strong></td>
            <td>Pull request events + manual trigger</td>
            <td>PR validation: lint, container builds, deploy proxy in tools, and plan against test</td>
        </tr>
        <tr>
            <td><strong>schedule.yml</strong></td>
            <td>Cron (daily at 5 PM PST)</td>
            <td>Auto-destroy Bastion for cost savings</td>
        </tr>
        <tr>
            <td><strong>apim-key-rotation.yml</strong></td>
            <td>Daily cron + manual trigger</td>
            <td>Rotate APIM subscription keys across environments (manual single-env or scheduled all-env flow)</td>
        </tr>
        <tr>
            <td><strong>pages.yml</strong></td>
            <td>Push to main (docs and Terraform roots) + manual trigger</td>
            <td>Generate docs and deploy GitHub Pages site</td>
        </tr>
    </tbody>
</table>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>Developer SDLC Flow (Branch → PR → DEV/TEST/PROD)</h2>

<p>The repository currently supports this sequence:</p>

<ol>
    <li><strong>Create feature branch</strong> from <code>main</code> (for example: <code>feature/&lt;work-item&gt;</code>) and commit changes.</li>
    <li><strong>Open PR</strong> to <code>main</code>, which triggers <code>pr-open.yml</code>.</li>
    <li><strong>PR validation</strong> runs lint + image builds + test-environment Terraform plan (via secure tunnel).</li>
    <li><strong>Merge to main</strong> once PR checks and repository review requirements pass.</li>
    <li><strong>Auto-apply to test</strong> runs through <code>main-merge-test-deploy.yml</code> on every merge/push to <code>main</code>.</li>
    <li><strong>Promote or experiment</strong> using <code>manual-dispatch.yml</code> by selecting <code>dev</code>, <code>test</code>, or <code>prod</code> with <code>plan/apply/destroy</code>.</li>
    <li><strong>Developer branch testing (occasional)</strong>: developers can run manual dispatch to <code>dev</code> from a feature/PR branch for targeted validation; use this sparingly and co-ordinate with other devs in the team.</li>
    <li><strong>Environment scope</strong>: <code>dev</code> does not include App Gateway or DNS Zone. Full ingress path validation is only available in <code>test</code> and <code>prod</code>.</li>
    <li><strong>Environment gating</strong> for <code>test</code> and <code>prod</code> is enforced through GitHub Environment protection rules (required reviewers/waits), because these workflows target environment-scoped jobs.</li>
</ol>

<pre>Feature Branch
   │
   └── Pull Request ──► pr-open.yml
                        ├─ .lint.yml
                        ├─ .builds.yml
                        ├─ .deployer.yml (tools/azure_proxy)
                        └─ .deployer-using-secure-tunnel.yml (test plan)
                                  │
                                  ▼
                             Merge to main
                                  │
                                    ├──► main-merge-test-deploy.yml (apply test)
                                    │
                                  ▼
                         manual-dispatch.yml
                      (dev/test/prod plan|apply|destroy)
                                  │
                                  └─ Environment approval gates for test/prod</pre>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>When Do I Need Self-Hosted Runners?</h2>

<p>GitHub-hosted runners (ubuntu-24.04) work for <strong>most operations</strong> because they only need control plane access. Self-hosted runners are only required when your Terraform code needs <strong>data plane access</strong> to private endpoints.</p>

<div class="alert alert-info">
    <strong>Understanding the Difference:</strong> See <a href="decisions.html#adr-011">ADR-011: Control Plane vs Data Plane</a> for a detailed explanation of why OIDC works for some operations but not others.
</div>

<table>
    <thead>
        <tr>
            <th>Operation</th>
            <th>Plane</th>
            <th>Public Runner?</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Create resources (VMs, VNets, Key Vault)</td>
            <td style="color: #22c55e;">Control</td>
            <td style="color: #22c55e;">&#10003; Yes</td>
            <td><code>azurerm_key_vault</code></td>
        </tr>
        <tr>
            <td>Configure settings, RBAC roles</td>
            <td style="color: #22c55e;">Control</td>
            <td style="color: #22c55e;">&#10003; Yes</td>
            <td><code>azurerm_role_assignment</code></td>
        </tr>
        <tr>
            <td>Deploy private endpoints</td>
            <td style="color: #22c55e;">Control</td>
            <td style="color: #22c55e;">&#10003; Yes</td>
            <td><code>azurerm_private_endpoint</code></td>
        </tr>
        <tr>
            <td><strong>Read/write Key Vault secrets</strong></td>
            <td style="color: #ef4444;">Data</td>
            <td style="color: #ef4444;">&#10007; No</td>
            <td><code>azurerm_key_vault_secret</code></td>
        </tr>
        <tr>
            <td><strong>Read/write Storage blobs</strong></td>
            <td style="color: #ef4444;">Data</td>
            <td style="color: #ef4444;">&#10007; No</td>
            <td><code>azurerm_storage_blob</code></td>
        </tr>
        <tr>
            <td><strong>Terraform state (if private)</strong></td>
            <td style="color: #ef4444;">Data</td>
            <td style="color: #ef4444;">&#10007; No</td>
            <td>Backend storage account</td>
        </tr>
    </tbody>
</table>

<div class="grid grid-2">
    <div class="card" style="border-left-color: #22c55e;">
        <h3 style="margin-top: 0;">Public Runners Work For</h3>
        <ul style="margin-bottom: 0;">
            <li>Deploying all infrastructure modules</li>
            <li>Network, Bastion, Jumpbox, Proxy</li>
            <li>Any resource that doesn't read secrets</li>
            <li>Documentation builds (pages.yml)</li>
        </ul>
    </div>
    <div class="card" style="border-left-color: #ef4444;">
        <h3 style="margin-top: 0;">Self-Hosted Required For</h3>
        <ul style="margin-bottom: 0;">
            <li>Terraform using <code>azurerm_key_vault_secret</code></li>
            <li>Private state backend (blocked by PE)</li>
            <li>Any code that reads secrets at plan time</li>
            <li>Database migrations, blob uploads</li>
        </ul>
    </div>
</div>

<div class="alert alert-warning">
    <strong>Cost Tip:</strong> If your Terraform doesn't need data plane access, stick with public runners. Self-hosted runners on Container Apps add cost. Only enable <code>github_runners_aca_enabled</code> if you actually need data plane access in CI/CD.
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>.deployer.yml (Reusable Workflow)</h2>

<p>Reusable Terraform workflow for <code>initial-setup/infra</code>, primarily used to manage the tools environment and targeted foundational modules.</p>

<div class="card">
    <h3>Inputs</h3>
    <table>
        <thead>
            <tr>
                <th>Input</th>
                <th>Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>environment_name</code></td>
                <td>string</td>
                <td>Target environment name (commonly <code>tools</code>)</td>
            </tr>
            <tr>
                <td><code>command</code></td>
                <td>string</td>
                <td>Terraform command (init, plan, apply, destroy)</td>
            </tr>
            <tr>
                <td><code>target_module</code></td>
                <td>string</td>
                <td>Required module target (for example: <code>azure_proxy</code>, <code>bastion</code>, <code>jumpbox</code>)</td>
            </tr>
        </tbody>
    </table>
</div>

<div class="card card-gold">
    <h3>Key Features</h3>
    <ul>
        <li><strong>OIDC Authentication</strong>: Uses <code>azure/login@v2</code> with federated credentials</li>
        <li><strong>Environment Isolation</strong>: Each environment has separate secrets and identity</li>
        <li><strong>Module Targeting</strong>: Deploy specific modules with <code>-target=module.name</code> (supports all modules including azure-proxy)</li>
        <li><strong>Optional Modules</strong>: Deploy only what you need—all modules except <code>network</code> and <code>monitoring</code> can be toggled on/off</li>
        <li><strong>ARM_USE_OIDC</strong>: Enabled for Terraform Azure provider</li>
    </ul>
</div>

<h3>Required Permissions</h3>

<pre>permissions:
  id-token: write   # Required for OIDC token generation
  contents: read    # Required for repository checkout</pre>

<div class="alert alert-warning">
    <strong>Important:</strong> Without <code>id-token: write</code> permission, the workflow cannot generate the OIDC token needed for Azure authentication.
</div>

<h2>.deployer-using-secure-tunnel.yml (Reusable Workflow)</h2>

<p>Reusable Terraform workflow for <code>infra-ai-hub</code>. It receives encrypted proxy outputs from <code>.deployer.yml</code>, starts Chisel + Privoxy, then runs stack deployment and (for apply in dev/test) integration tests.</p>

<div class="card">
    <h3>Highlights</h3>
    <ul>
        <li><strong>Validated environments</strong>: <code>dev</code>, <code>test</code>, <code>prod</code></li>
        <li><strong>Secure tunnel bootstrap</strong>: decrypts <code>proxy_url</code>/<code>proxy_auth</code> with <code>GPG_PASSPHRASE</code></li>
        <li><strong>Proxy-aware Terraform</strong>: sets <code>HTTP_PROXY</code>, <code>HTTPS_PROXY</code>, and <code>NO_PROXY</code></li>
        <li><strong>Integration tests</strong>: runs <code>tests/integration/run-tests.sh --env &lt;env&gt;</code> after successful <code>apply</code> in dev/test</li>
    </ul>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>.lint.yml (Reusable Workflow)</h2>

<p>Reusable lint workflow used by PR checks. It sets up Terraform, TFLint, and Python, installs pre-commit, and runs the local pre-commit Terraform hook either diff-based or full-repo.</p>

<div class="card card-gold">
    <h3>What It Runs</h3>
    <ul>
        <li><code>python -m pip install --upgrade pre-commit</code></li>
        <li><code>pre-commit run --from-ref ... --to-ref ...</code> for PR changes</li>
        <li>Fallback to <code>pre-commit run --all-files</code> when SHAs are not provided</li>
    </ul>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>.builds.yml (Container Build Workflow)</h2>

<p>Reusable workflow for building and pushing container images to GitHub Container Registry (GHCR). Supports matrix builds for multiple packages including the azure-proxy services.</p>

<div class="card">
    <h3>Built Packages</h3>
    <ul>
        <li><strong>azure-proxy/chisel</strong> - Chisel-based secure tunnel server for private network access</li>
        <li><strong>azure-proxy/privoxy</strong> - Privoxy HTTP/SOCKS proxy server</li>
    </ul>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>add-or-remove-module.yml</h2>

<p>Manual workflow for deploying or destroying infrastructure modules on demand. Evolved from the earlier bastion-only workflow to support all optional modules (bastion, jumpbox, azure_proxy, github_runners_aca).</p>

<div class="grid grid-2">
    <div class="card">
        <h3>When to Use</h3>
        <ul>
            <li><strong>Deploy Module</strong>: When you need to provision a specific infrastructure module</li>
            <li><strong>Destroy Module</strong>: When done, to save costs or clean up resources</li>
        </ul>
    </div>
    <div class="card">
        <h3>How to Run</h3>
        <ol>
            <li>Go to Actions tab in GitHub</li>
            <li>Select "Deploy or Remove Bastion Host"</li>
            <li>Click "Run workflow"</li>
            <li>Choose <code>tools</code>, module, and command</li>
        </ol>
    </div>
</div>

<h3>Workflow Inputs</h3>

<table>
    <thead>
        <tr>
            <th>Input</th>
            <th>Options</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>environment_name</code></td>
            <td>tools</td>
            <td>Target environment</td>
        </tr>
        <tr>
            <td><code>module</code></td>
            <td>bastion, jumpbox, azure_proxy, github_runners_aca</td>
            <td>Module to deploy or destroy</td>
        </tr>
        <tr>
            <td><code>command</code></td>
            <td>apply, destroy</td>
            <td>Terraform command to execute</td>
        </tr>
    </tbody>
</table>

<div class="alert alert-info">
    <strong>Cost Optimization:</strong> Azure Bastion has hourly charges (~$0.19/hour for Basic SKU). Deploy only when needed and destroy when done.
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>pr-open.yml (Pull Request Checks)</h2>

<p>Runs on pull request events (and manual dispatch) to provide fast CI signal before merge.</p>

<div class="card card-gold">
    <h3>Automated Checks</h3>
    <ul>
        <li><strong>Terraform Linting</strong>: Invokes <code>.lint.yml</code> (pre-commit fmt + tflint)</li>
        <li><strong>Container Build Validation</strong>: Invokes <code>.builds.yml</code> for proxy images</li>
        <li><strong>Tools Proxy Bootstrap</strong>: Invokes <code>.deployer.yml</code> to deploy <code>azure_proxy</code> in <code>tools</code></li>
        <li><strong>Plan Against Test</strong>: Invokes <code>.deployer-using-secure-tunnel.yml</code> with <code>command=plan</code></li>
        <li><strong>PR Signal</strong>: Fails fast if any checks are broken</li>
    </ul>
</div>

<div class="alert alert-info">
    <strong>Note:</strong> The pr-open workflow must pass before a PR can be merged. Address any failures shown in the PR checks.
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>schedule.yml (Scheduled Cleanup)</h2>

<p>Automatically destroys Bastion every day at 5 PM PST to prevent unnecessary charges.</p>

<div class="card">
    <h3>Schedule</h3>
    <pre># Runs daily at 5 PM PST (1 AM UTC next day)
on:
  schedule:
    - cron: "0 1 * * *"</pre>
</div>

<div class="card card-gold">
    <h3>Workflow Logic</h3>
    <ol>
        <li><strong>Check if Bastion exists</strong>: Uses Azure CLI to query the Bastion resource</li>
        <li><strong>Conditional destroy</strong>: Only runs Terraform destroy if Bastion is found</li>
        <li><strong>Status notification</strong>: Reports whether Bastion was destroyed or already removed</li>
    </ol>
</div>

<h3>Jobs Flow</h3>

<pre>check-and-destroy-bastion
         │
         ├── bastion_exists=true ──► destroy-bastion ──► notification
         │
         └── bastion_exists=false ──────────────────────► notification</pre>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>manual-dispatch.yml (Manual Promotion Workflow)</h2>

<p>Use this workflow to run <code>plan</code>, <code>apply</code>, or <code>destroy</code> for <code>dev</code>, <code>test</code>, and <code>prod</code>.</p>

<div class="card">
    <h3>How It Works</h3>
    <ol>
        <li>Deploys/refreshes <code>azure_proxy</code> in <code>tools</code> via <code>.deployer.yml</code></li>
        <li>Passes encrypted proxy outputs to <code>.deployer-using-secure-tunnel.yml</code></li>
        <li>Executes selected Terraform command in chosen environment</li>
    </ol>
</div>

<div class="alert alert-info">
    <strong>Gated Promotion:</strong> Jobs in this workflow bind to GitHub Environments (<code>dev</code>, <code>test</code>, <code>prod</code>). Configure required reviewers on <code>test</code> and <code>prod</code> to enforce approval gates before deployment jobs start.
</div>

<div class="alert alert-warning">
    <strong>Dev Environment Scope:</strong> Developers may occasionally deploy to <code>dev</code> from a PR branch using workflow dispatch to test specific features. The <code>dev</code> environment does <strong>not</strong> include App Gateway or DNS Zone; end-to-end ingress and DNS validation is only supported in <code>test</code> and <code>prod</code>.
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>main-merge-test-deploy.yml (Auto Apply on Main)</h2>

<p>This workflow runs on every push to <code>main</code> and automatically applies infrastructure to <code>test</code>.</p>

<div class="card">
    <h3>Execution Flow</h3>
    <ol>
        <li>Deploy/update <code>azure_proxy</code> in <code>tools</code> using <code>.deployer.yml</code></li>
        <li>Pass encrypted proxy outputs to <code>.deployer-using-secure-tunnel.yml</code></li>
        <li>Run <code>apply</code> against <code>test</code></li>
    </ol>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>Concurrency Strategy</h2>

<p>Several workflows and reusable jobs use <code>concurrency</code> to prevent race conditions and conflicting Terraform operations.</p>

<table>
    <thead>
        <tr>
            <th>Workflow/Job</th>
            <th>Concurrency Group</th>
            <th>Why It Helps</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>.deployer.yml</code></td>
            <td><code>tools</code></td>
            <td>Serializes tools/bootstrap changes so multiple runs don't mutate shared proxy infra at the same time.</td>
        </tr>
        <tr>
            <td><code>.deployer-using-secure-tunnel.yml</code></td>
            <td><code>${environment_name}</code></td>
            <td>Ensures only one Terraform operation per environment runs at once (for example, only one test apply).</td>
        </tr>
        <tr>
            <td><code>pr-open.yml</code> builds job</td>
            <td><code>builds-${PR number}</code> (cancel in-progress)</td>
            <td>Stops stale image builds when a newer commit arrives in the same PR.</td>
        </tr>
        <tr>
            <td><code>manual-dispatch.yml</code></td>
            <td><code>manual-deploy-${run_id}</code></td>
            <td>Keeps each manually triggered deployment isolated and traceable to a single run.</td>
        </tr>
        <tr>
            <td><code>main-merge-test-deploy.yml</code></td>
            <td><code>deploy-test-on-main</code></td>
            <td>Queues merges to main so test applies execute in order and avoid state lock contention.</td>
        </tr>
    </tbody>
</table>

<div class="alert alert-info">
    <strong>Practical Effect:</strong> Concurrency improves deployment reliability by reducing Terraform state lock failures, avoiding overlapping applies, and ensuring each environment converges predictably.
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>apim-key-rotation.yml (Scheduled + Manual)</h2>

<p>Rotates APIM subscription keys using OIDC-authenticated Azure CLI execution.</p>

<div class="grid grid-2">
    <div class="card">
        <h3>Manual Mode</h3>
        <ul>
            <li>Trigger with <code>workflow_dispatch</code></li>
            <li>Select environment: <code>dev</code>, <code>test</code>, <code>prod</code></li>
            <li>Optional <code>dry_run=true</code> for safe preview</li>
        </ul>
    </div>
    <div class="card card-gold">
        <h3>Scheduled Mode</h3>
        <ul>
            <li>Runs daily at <code>0 9 * * *</code> UTC</li>
            <li>Executes dev and test first</li>
            <li>Executes prod only after test succeeds</li>
        </ul>
    </div>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>pages.yml (Documentation)</h2>

<p>Deploys this documentation site to GitHub Pages when changes are pushed to docs or Terraform roots (so generated references stay current).</p>

<div class="card">
    <h3>Triggers</h3>
    <ul>
        <li><strong>Push to main</strong>: When files in <code>docs/**</code>, <code>initial-setup/infra/**</code>, or <code>infra-ai-hub/**</code> change</li>
        <li><strong>Manual</strong>: Can be triggered manually via <code>workflow_dispatch</code></li>
    </ul>
</div>

<div class="card">
    <h3>Deployment Steps</h3>
    <ol>
        <li>Checkout repository</li>
        <li>Run <code>docs/generate-tf-docs.sh</code> to refresh Terraform reference content</li>
        <li>Run <code>docs/build.sh</code> to generate HTML from templates</li>
        <li>Configure GitHub Pages</li>
        <li>Upload <code>docs/</code> folder as artifact</li>
        <li>Deploy to GitHub Pages</li>
    </ol>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>Environment Secrets</h2>

<p>Each GitHub environment requires these secrets (created by <code>initial-azure-setup.sh</code>):</p>

<table>
    <thead>
        <tr>
            <th>Secret</th>
            <th>Description</th>
            <th>Source</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>AZURE_CLIENT_ID</code></td>
            <td>Managed Identity client ID</td>
            <td>Created by setup script</td>
        </tr>
        <tr>
            <td><code>AZURE_TENANT_ID</code></td>
            <td>Azure AD tenant ID</td>
            <td>Your Azure subscription</td>
        </tr>
        <tr>
            <td><code>AZURE_SUBSCRIPTION_ID</code></td>
            <td>Target subscription ID</td>
            <td>Your Azure subscription</td>
        </tr>
        <tr>
            <td><code>VNET_RESOURCE_GROUP_NAME</code></td>
            <td>Resource group containing VNet</td>
            <td>Your infrastructure</td>
        </tr>
        <tr>
            <td><code>VNET_NAME</code></td>
            <td>Existing VNet name</td>
            <td>Your infrastructure</td>
        </tr>
        <tr>
            <td><code>VNET_ADDRESS_SPACE</code></td>
            <td>VNet CIDR block</td>
            <td>Your infrastructure</td>
        </tr>
    </tbody>
</table>

<h2>Running Workflows Locally</h2>

<p>For local development and testing, use the deployment scripts in each Terraform root:</p>

<pre># Ensure you're logged in
az login

# Initial setup / tools
./initial-setup/infra/deploy-terraform.sh init
./initial-setup/infra/deploy-terraform.sh plan
./initial-setup/infra/deploy-terraform.sh apply</pre>

<pre># AI Hub stacks
./infra-ai-hub/scripts/deploy-terraform.sh plan dev
./infra-ai-hub/scripts/deploy-terraform.sh apply test</pre>

<div class="alert alert-info">
    <strong>Note:</strong> Local runs use your Azure CLI credentials instead of OIDC. Make sure you have the required permissions.
</div>
