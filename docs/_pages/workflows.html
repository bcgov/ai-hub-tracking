<!-- TITLE: GitHub Workflows -->
<!-- NAV: workflows -->

<h1>GitHub Actions Workflows</h1>

<p>This project uses GitHub Actions for automated infrastructure deployments with OIDC authentication to Azure.</p>

<h2>Workflow Overview</h2>

<table>
    <thead>
        <tr>
            <th>Workflow</th>
            <th>Trigger</th>
            <th>Purpose</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><strong>.builds.yml</strong></td>
            <td>Called by other workflows</td>
            <td>Reusable container build workflow for azure-proxy images</td>
        </tr>
        <tr>
            <td><strong>.deployer.yml</strong></td>
            <td>Called by other workflows</td>
            <td>Reusable Terraform deployer for <code>initial-setup/infra</code> (tools bootstrap and module-level operations)</td>
        </tr>
        <tr>
            <td><strong>.deployer-using-secure-tunnel.yml</strong></td>
            <td>Called by other workflows</td>
            <td>Reusable Terraform deployer for <code>infra-ai-hub</code> through Chisel + Privoxy secure tunnel</td>
        </tr>
        <tr>
            <td><strong>.lint.yml</strong></td>
            <td>Called by other workflows</td>
            <td>Reusable validation: pre-commit (<code>terraform fmt</code> + <code>tflint</code>), conventional commits, fork check</td>
        </tr>
        <tr>
            <td><strong>add-or-remove-module.yml</strong></td>
            <td>Manual (workflow_dispatch)</td>
            <td>Deploy or destroy selected tools modules (bastion, azure_proxy, jumpbox, github_runners_aca)</td>
        </tr>
        <tr>
            <td><strong>manual-dispatch.yml</strong></td>
            <td>Manual (workflow_dispatch)</td>
            <td>Run <code>plan/apply/destroy</code> for dev/test/prod; prod apply requires a semver tag (e.g. <code>v1.2.3</code>) and creates a GitHub Release</td>
        </tr>
        <tr>
            <td><strong>merge-main.yml</strong></td>
            <td>Push to <code>main</code></td>
            <td>Automatic post-merge: semantic version tag via conventional commits, apply infrastructure to test</td>
        </tr>
        <tr>
            <td><strong>pr-open.yml</strong></td>
            <td>Pull request events + manual trigger</td>
            <td>PR validation: lint, container builds, deploy proxy in tools, and plan against test</td>
        </tr>
        <tr>
            <td><strong>schedule.yml</strong></td>
            <td>Cron (daily at 5 PM PST)</td>
            <td>Auto-destroy Bastion for cost savings</td>
        </tr>
        <tr>
            <td><strong>apim-key-rotation.yml</strong></td>
            <td>Daily cron + manual trigger</td>
            <td>Rotate APIM subscription keys across environments (manual single-env or scheduled all-env flow)</td>
        </tr>
        <tr>
            <td><strong>pages.yml</strong></td>
            <td>Push to main (docs and Terraform roots) + manual trigger</td>
            <td>Generate docs and deploy GitHub Pages site</td>
        </tr>
    </tbody>
</table>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>Developer SDLC Flow (Branch → PR → TEST → PROD)</h2>

<p>The repository enforces a promote-through-environments workflow. Every change flows through a validated path before reaching production.</p>

<ol>
    <li><strong>Create feature branch</strong> from <code>main</code> (e.g. <code>feat/&lt;work-item&gt;</code>, <code>fix/&lt;issue&gt;</code>) and commit changes.</li>
    <li><strong>Open PR</strong> to <code>main</code>, which triggers <code>pr-open.yml</code>:
        <ul>
            <li>Lint (pre-commit: terraform fmt + tflint, conventional commit title, fork check)</li>
            <li>Container image builds</li>
            <li>Terraform plan against <code>test</code> (via secure tunnel) — summary appended to PR description</li>
        </ul>
    </li>
    <li><strong>Merge to main</strong> once PR checks and code review pass.</li>
    <li><strong>Auto-apply to test + semver tag</strong>: <code>merge-main.yml</code> starts two jobs concurrently — semantic versioning (conventional commit history → <code>v1.2.3</code> tag + <code>CHANGELOG.md</code> update) and proxy bootstrap in <code>tools</code>. Once the proxy is up, it applies infrastructure to <code>test</code> through the Chisel tunnel. After a successful apply, integration tests run automatically (two phases — see below).</li>
    <li><strong>Promote to prod</strong>: Use <code>manual-dispatch.yml</code>, select <code>prod</code> + <code>apply</code>, and provide the semver tag. <strong>This is gated — requires approval from designated reviewers</strong> (configured in the GitHub <code>prod</code> environment protection rules).</li>
    <li><strong>Release created</strong>: After successful prod apply, a GitHub Release is automatically created from the deployed tag with deployment metadata.</li>
</ol>

<div class="alert alert-warning">
    <div><strong>PROD is gated:</strong> The <code>prod</code> environment has required reviewers configured as a GitHub Environment protection rule. Any workflow job targeting <code>prod</code> will pause and wait for manual approval before executing. Only designated reviewers can approve.</div>
</div>

<div class="alert alert-info">
    <div><strong>Developer branch testing (occasional):</strong> Developers can run manual dispatch to <code>dev</code> from a feature/PR branch for targeted validation; use this sparingly and co-ordinate with other devs. The <code>dev</code> environment does <strong>not</strong> include App Gateway or DNS Zone — full ingress path validation is only available in <code>test</code> and <code>prod</code>.</div>
</div>

<pre>Feature Branch
   │
   └── Pull Request ──► pr-open.yml
                        ├─ .lint.yml (fmt, tflint, conventional commits, fork check)
                        ├─ .builds.yml
                        ├─ .deployer.yml (tools/azure_proxy)
                        ├─ .deployer-using-secure-tunnel.yml (test plan)
                        └─ Update PR description with plan summary
                                  │
                                  ▼
                             Merge to main
                                  │
                                  ▼
                        merge-main.yml
                        ├─ Semantic version tag (v1.2.3) ─────────────────── concurrent
                        ├─ Deploy azure_proxy (tools) ───────────────────────────────┤
                        └─ Apply to test (via Chisel tunnel)
                             └─ Integration tests (post-apply)
                                  ├─ Direct: all tests except apim-key-rotation.bats
                                  └─ Via proxy: apim-key-rotation.bats (KV private endpoint)
                                  │
                                  ▼
                        manual-dispatch.yml (prod + apply + tag)
                        ├─ ⏸ Requires prod environment approval
                        ├─ Apply to prod using tagged commit
                        └─ Create GitHub Release</pre>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>Advanced Branching Patterns</h2>

<p>The basic SDLC flow above covers the single-feature-per-PR path. In practice, teams often need to coordinate dependent work or bundle multiple features into a single release. Two patterns handle this: <strong>Stacked PRs</strong> and <strong>Release PRs</strong>.</p>

<h3>Stacked PRs (Dependent Feature Chains)</h3>

<p>Use stacked PRs when a feature depends on another feature that hasn't merged to <code>main</code> yet. Each PR in the stack targets the previous branch instead of <code>main</code>.</p>

<div class="card card-gold">
    <h3>When to Use</h3>
    <ul>
        <li>Feature B requires infrastructure created by Feature A (e.g. a new subnet added in A is referenced in B)</li>
        <li>Breaking a large change into reviewable, incremental PRs</li>
        <li>Multiple developers working on sequential pieces of a story</li>
    </ul>
</div>

<div class="card">
    <h3>How It Works</h3>
    <ol>
        <li>Create <code>feat/base-network</code> from <code>main</code> → open <strong>PR #1</strong> targeting <code>main</code></li>
        <li>Create <code>feat/add-apim-policy</code> from <code>feat/base-network</code> → open <strong>PR #2</strong> targeting <code>feat/base-network</code></li>
        <li>Each PR triggers <code>pr-open.yml</code> independently for lint and plan</li>
        <li>Merge <strong>PR #1</strong> first (bottom of the stack) — this triggers <code>merge-main.yml</code></li>
        <li><strong>Retarget PR #2</strong> to <code>main</code> and rebase onto updated <code>main</code></li>
        <li>Merge <strong>PR #2</strong> — triggers another <code>merge-main.yml</code> run with its own semver tag</li>
    </ol>
</div>

<pre>main ─────────────────────────┬───────────────────┬──────►
   \                          │ merge PR #1        │ merge PR #2
    └─ feat/base-network ─────┘   (v1.3.0)        │
         \                                         │
          └─ feat/add-apim-policy ─── rebase ──────┘
                                                 (v1.4.0)</pre>

<div class="alert alert-warning">
    <div><strong>Important:</strong> Always merge bottom-up. If you merge PR #2 before PR #1, the diff will include both sets of changes and the base branch won't exist in <code>main</code> yet. After merging the base PR, <strong>rebase</strong> the dependent branch onto <code>main</code> to pick up any squash-merge differences before merging.</div>
</div>

<div class="alert alert-info">
    <div><strong>CI Behaviour:</strong> Each PR in the stack runs <code>pr-open.yml</code> against <code>test</code>. The plan for PR #2 will show changes from both branches while PR #1 is open (because the diff includes the base). After PR #1 merges, re-running PR #2's checks shows only its own changes. Each merge to <code>main</code> produces its own semver tag.</div>
</div>

<h3>Release PRs (Bundled Multi-Feature Releases)</h3>

<p>Use a Release PR when multiple developers are working on separate features that should ship together as a single coordinated release. All feature branches merge into a shared <strong>release branch</strong>, which then opens one PR to <code>main</code>.</p>

<div class="card card-gold">
    <h3>When to Use</h3>
    <ul>
        <li>A planned release includes work from multiple developers across different modules</li>
        <li>Features need integration testing together before merging to <code>main</code></li>
        <li>You want one semver tag to represent the entire release bundle (e.g. a sprint deliverable)</li>
        <li>Coordinating breaking changes that span multiple Terraform stacks</li>
    </ul>
</div>

<div class="card">
    <h3>How It Works</h3>
    <ol>
        <li>Create a release branch from <code>main</code>: <code>release/sprint-42</code> (or <code>release/apim-v2</code>, etc.)</li>
        <li>Developers create feature branches from the release branch:
            <ul>
                <li><code>feat/new-tenant-config</code> → PR targeting <code>release/sprint-42</code></li>
                <li><code>feat/apim-rate-limits</code> → PR targeting <code>release/sprint-42</code></li>
                <li><code>fix/dns-zone-ttl</code> → PR targeting <code>release/sprint-42</code></li>
            </ul>
        </li>
        <li>Feature PRs are reviewed and merged into the release branch (these merges do <strong>not</strong> trigger <code>merge-main.yml</code> since they don't target <code>main</code>)</li>
        <li>Optionally deploy the release branch to <code>dev</code> via <code>manual-dispatch.yml</code> to validate the combined changes</li>
        <li>When all features are complete, open one <strong>Release PR</strong>: <code>release/sprint-42</code> → <code>main</code></li>
        <li>The Release PR triggers <code>pr-open.yml</code> — the plan shows the aggregate of all bundled changes</li>
        <li>Merge the Release PR → <code>merge-main.yml</code> creates one semver tag and applies to <code>test</code></li>
    </ol>
</div>

<pre>main ─────────────────────────────────────────┬──────────►
   \                                           │ merge Release PR
    └─ release/sprint-42 ───┬──────┬──────────┘  (v2.0.0)
         \                  │      │
          ├─ feat/tenant ───┘      │
          │                        │
          └─ feat/rate-limits ─────┘</pre>

<div class="alert alert-info">
    <div><strong>CI Behaviour:</strong> PRs targeting the release branch still trigger <code>pr-open.yml</code> (lint and plan), giving each feature its own review cycle. The final Release PR to <code>main</code> runs the full pipeline and shows a combined plan. Only the merge to <code>main</code> triggers <code>merge-main.yml</code> for semver tagging and test apply.</div>
</div>

<div class="alert alert-warning">
    <div><strong>PR Title Convention:</strong> The Release PR title must follow <a href="https://www.conventionalcommits.org/en/v1.0.0/">Conventional Commits</a> (e.g. <code>feat: sprint 42 release — tenant config and rate limits</code>) since it controls the semver bump. Use <code>feat:</code> for minor, <code>fix:</code> for patch, or include <code>BREAKING CHANGE</code> in the body for major.</div>
</div>

<h3>Choosing Between Stacked PRs and Release PRs</h3>

<table>
    <thead>
        <tr>
            <th></th>
            <th>Stacked PRs</th>
            <th>Release PR</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><strong>Best for</strong></td>
            <td>Sequential/dependent changes by 1–2 developers</td>
            <td>Parallel independent features by multiple developers</td>
        </tr>
        <tr>
            <td><strong>Semver tags</strong></td>
            <td>One tag per merged PR (e.g. v1.3.0, v1.4.0)</td>
            <td>One tag for the entire bundle (e.g. v2.0.0)</td>
        </tr>
        <tr>
            <td><strong>Review granularity</strong></td>
            <td>Each PR is reviewed independently with a focused diff</td>
            <td>Feature PRs reviewed individually; Release PR shows combined diff</td>
        </tr>
        <tr>
            <td><strong>merge-main.yml runs</strong></td>
            <td>Triggers once per PR merged to main</td>
            <td>Triggers once for the entire release</td>
        </tr>
        <tr>
            <td><strong>Risk</strong></td>
            <td>Rebase conflicts after base merges</td>
            <td>Release branch can drift from main if long-lived</td>
        </tr>
        <tr>
            <td><strong>Recommendation</strong></td>
            <td>Keep stacks shallow (2–3 deep max)</td>
            <td>Keep release branches short-lived; rebase from main regularly</td>
        </tr>
    </tbody>
</table>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>When Do I Need Self-Hosted Runners?</h2>

<div class="alert alert-info">
    <div>
        <strong>How this platform solves the private-endpoint problem:</strong> All CI/CD in this repo runs on <strong>standard GitHub-hosted runners</strong> (<code>ubuntu-24.04</code>). To reach private endpoints, the Terraform deployer spins up a <strong>Chisel SOCKS tunnel + Privoxy</strong> inside Docker on the runner, routing data-plane traffic through a proxy deployed in the <code>tools</code> VNet. No self-hosted runners are needed for this repo's own pipelines.
        <br><br>
        The optional <strong><code>github_runners_aca</code></strong> module (deployable via <code>add-or-remove-module.yml</code>) can provision self-hosted runners inside the VNet. Use this when <em>other repos</em> or workloads need persistent VNet-internal compute — not for this repo's own CI/CD.
    </div>
</div>

<p>The table below describes the general pattern. Data-plane work that <em>can't</em> use the Chisel tunnel approach — for example, other repos without the proxy setup — would still need self-hosted runners.</p>

<div class="alert alert-info">
    <div><strong>Understanding the Difference:</strong> See <a href="decisions.html#adr-011">ADR-011: Control Plane vs Data Plane</a> for a detailed explanation of why OIDC works for some operations but not others.</div>
</div>

<table>
    <thead>
        <tr>
            <th>Operation</th>
            <th>Plane</th>
            <th>Public Runner?</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Create resources (VMs, VNets, Key Vault)</td>
            <td style="color: #22c55e;">Control</td>
            <td style="color: #22c55e;">&#10003; Yes</td>
            <td><code>azurerm_key_vault</code></td>
        </tr>
        <tr>
            <td>Configure settings, RBAC roles</td>
            <td style="color: #22c55e;">Control</td>
            <td style="color: #22c55e;">&#10003; Yes</td>
            <td><code>azurerm_role_assignment</code></td>
        </tr>
        <tr>
            <td>Deploy private endpoints</td>
            <td style="color: #22c55e;">Control</td>
            <td style="color: #22c55e;">&#10003; Yes</td>
            <td><code>azurerm_private_endpoint</code></td>
        </tr>
        <tr>
            <td><strong>Read/write Key Vault secrets</strong></td>
            <td style="color: #ef4444;">Data</td>
            <td style="color: #ef4444;">&#10007; No</td>
            <td><code>azurerm_key_vault_secret</code></td>
        </tr>
        <tr>
            <td><strong>Read/write Storage blobs</strong></td>
            <td style="color: #ef4444;">Data</td>
            <td style="color: #ef4444;">&#10007; No</td>
            <td><code>azurerm_storage_blob</code></td>
        </tr>
        <tr>
            <td><strong>Terraform state (if private)</strong></td>
            <td style="color: #ef4444;">Data</td>
            <td style="color: #ef4444;">&#10007; No</td>
            <td>Backend storage account</td>
        </tr>
    </tbody>
</table>

<div class="grid grid-2">
    <div class="card" style="border-left-color: #22c55e;">
        <h3 style="margin-top: 0;">Public Runners Work For</h3>
        <ul style="margin-bottom: 0;">
            <li>Deploying all infrastructure modules</li>
            <li>Network, Bastion, Jumpbox, Proxy</li>
            <li>Any resource that doesn't read secrets</li>
            <li>Documentation builds (pages.yml)</li>
        </ul>
    </div>
    <div class="card" style="border-left-color: #ef4444;">
        <h3 style="margin-top: 0;">Self-Hosted Required For</h3>
        <ul style="margin-bottom: 0;">
            <li>Terraform using <code>azurerm_key_vault_secret</code></li>
            <li>Private state backend (blocked by PE)</li>
            <li>Any code that reads secrets at plan time</li>
            <li>Database migrations, blob uploads</li>
        </ul>
    </div>
</div>

<div class="alert alert-warning">
    <div><strong>Cost Tip:</strong> If your Terraform doesn't need data plane access, stick with public runners. Self-hosted runners on Container Apps add cost. Only enable <code>github_runners_aca_enabled</code> if you actually need data plane access in CI/CD.</div>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>.deployer.yml (Reusable Workflow)</h2>

<p>Reusable Terraform workflow for <code>initial-setup/infra</code>, primarily used to manage the tools environment and targeted foundational modules.</p>

<div class="card">
    <h3>Inputs</h3>
    <table>
        <thead>
            <tr>
                <th>Input</th>
                <th>Type</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>environment_name</code></td>
                <td>string</td>
                <td>Target environment name (commonly <code>tools</code>)</td>
            </tr>
            <tr>
                <td><code>command</code></td>
                <td>string</td>
                <td>Terraform command (init, plan, apply, destroy)</td>
            </tr>
            <tr>
                <td><code>target_module</code></td>
                <td>string</td>
                <td>Required module target (for example: <code>azure_proxy</code>, <code>bastion</code>, <code>jumpbox</code>)</td>
            </tr>
        </tbody>
    </table>
</div>

<div class="card card-gold">
    <h3>Key Features</h3>
    <ul>
        <li><strong>OIDC Authentication</strong>: Uses <code>azure/login@v2</code> with federated credentials</li>
        <li><strong>Environment Isolation</strong>: Each environment has separate secrets and identity</li>
        <li><strong>Module Targeting</strong>: Deploy specific modules with <code>-target=module.name</code> (supports all modules including azure-proxy)</li>
        <li><strong>Optional Modules</strong>: Deploy only what you need—all modules except <code>network</code> and <code>monitoring</code> can be toggled on/off</li>
        <li><strong>ARM_USE_OIDC</strong>: Enabled for Terraform Azure provider</li>
    </ul>
</div>

<h3>Required Permissions</h3>

<pre>permissions:
  id-token: write   # Required for OIDC token generation
  contents: read    # Required for repository checkout</pre>

<div class="alert alert-warning">
    <div><strong>Important:</strong> Without <code>id-token: write</code> permission, the workflow cannot generate the OIDC token needed for Azure authentication.</div>
</div>

<h2>.deployer-using-secure-tunnel.yml (Reusable Workflow)</h2>

<p>Reusable Terraform workflow for <code>infra-ai-hub</code>. It receives encrypted proxy outputs from <code>.deployer.yml</code>, starts Chisel + Privoxy, then runs stack deployment and (for apply in dev/test) integration tests.</p>

<div class="card">
    <h3>Highlights</h3>
    <ul>
        <li><strong>Validated environments</strong>: <code>dev</code>, <code>test</code>, <code>prod</code></li>
        <li><strong>Secure tunnel bootstrap</strong>: decrypts <code>proxy_url</code>/<code>proxy_auth</code> with <code>GPG_PASSPHRASE</code></li>
        <li><strong>Proxy-aware Terraform</strong>: sets <code>HTTP_PROXY</code>, <code>HTTPS_PROXY</code>, and <code>NO_PROXY</code></li>
        <li><strong>Integration tests</strong> (after successful <code>apply</code> in dev/test) — two phases:
            <ul>
                <li><strong>Direct (no proxy):</strong> all suites <em>except</em> <code>apim-key-rotation.bats</code> — APIM and App Gateway are public endpoints; proxy not required</li>
                <li><strong>Via proxy:</strong> <code>apim-key-rotation.bats</code> only — Key Vault is private-endpoint only (<code>public_network_access_enabled=false</code>), so the KV fallback (<code>az keyvault secret show</code>) must route through the Chisel tunnel</li>
            </ul>
        </li>
    </ul>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>.lint.yml (Reusable Workflow)</h2>

<p>Reusable validation workflow used by PR checks. Runs Terraform formatting and linting, enforces PR title conventions, and blocks forks.</p>

<div class="card card-gold">
    <h3>What It Runs</h3>
    <ul>
        <li><strong>Pre-commit hooks</strong>: <code>terraform fmt</code> + <code>tflint</code> (diff-based when possible, full-repo fallback)</li>
        <li><strong>Conventional Commits</strong>: Validates PR title follows <a href="https://www.conventionalcommits.org/en/v1.0.0/">Conventional Commits</a> spec (e.g. <code>feat:</code>, <code>fix:</code>, <code>chore:</code>)</li>
        <li><strong>Fork check</strong>: Rejects PRs from forked repositories</li>
        <li><strong>Summary on failure</strong>: When any check fails, prints a consolidated error summary with common reasons</li>
    </ul>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>.builds.yml (Container Build Workflow)</h2>

<p>Reusable workflow for building and pushing container images to GitHub Container Registry (GHCR). Supports matrix builds for multiple packages including the azure-proxy services.</p>

<div class="card">
    <h3>Built Packages</h3>
    <ul>
        <li><strong>azure-proxy/chisel</strong> - Chisel-based secure tunnel server for private network access</li>
        <li><strong>azure-proxy/privoxy</strong> - Privoxy HTTP/SOCKS proxy server</li>
    </ul>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>add-or-remove-module.yml</h2>

<p>Manual workflow for deploying or destroying infrastructure modules on demand. Evolved from the earlier bastion-only workflow to support all optional modules (bastion, jumpbox, azure_proxy, github_runners_aca).</p>

<div class="grid grid-2">
    <div class="card">
        <h3>When to Use</h3>
        <ul>
            <li><strong>Deploy Module</strong>: When you need to provision a specific infrastructure module</li>
            <li><strong>Destroy Module</strong>: When done, to save costs or clean up resources</li>
        </ul>
    </div>
    <div class="card">
        <h3>How to Run</h3>
        <ol>
            <li>Go to Actions tab in GitHub</li>
            <li>Select "Deploy or Remove Bastion Host"</li>
            <li>Click "Run workflow"</li>
            <li>Choose <code>tools</code>, module, and command</li>
        </ol>
    </div>
</div>

<h3>Workflow Inputs</h3>

<table>
    <thead>
        <tr>
            <th>Input</th>
            <th>Options</th>
            <th>Description</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>environment_name</code></td>
            <td>tools</td>
            <td>Target environment</td>
        </tr>
        <tr>
            <td><code>module</code></td>
            <td>bastion, jumpbox, azure_proxy, github_runners_aca</td>
            <td>Module to deploy or destroy</td>
        </tr>
        <tr>
            <td><code>command</code></td>
            <td>apply, destroy</td>
            <td>Terraform command to execute</td>
        </tr>
    </tbody>
</table>

<div class="alert alert-info">
    <div><strong>Cost Optimization:</strong> Azure Bastion has hourly charges (~$0.19/hour for Basic SKU). Deploy only when needed and destroy when done.</div>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>pr-open.yml (Pull Request Checks)</h2>

<p>Runs on pull request events (and manual dispatch) to provide fast CI signal before merge.</p>

<div class="card card-gold">
    <h3>Automated Checks</h3>
    <ul>
        <li><strong>Validation</strong>: Invokes <code>.lint.yml</code> (pre-commit fmt + tflint, conventional commits, fork check)</li>
        <li><strong>Container Build Validation</strong>: Invokes <code>.builds.yml</code> for proxy images</li>
        <li><strong>Tools Proxy Bootstrap</strong>: Invokes <code>.deployer.yml</code> to deploy <code>azure_proxy</code> in <code>tools</code></li>
        <li><strong>Plan Against Test</strong>: Invokes <code>.deployer-using-secure-tunnel.yml</code> with <code>command=plan</code></li>
        <li><strong>PR Description Update</strong>: Appends the test plan summary to the PR description under <em>AI Hub Infra Changes</em></li>
        <li><strong>Final Result</strong>: Reports pass/fail per job with clear ✅/❌ indicators; PR-Description is non-blocking</li>
    </ul>
</div>

<div class="alert alert-info">
    <div><strong>Note:</strong> The pr-open workflow must pass before a PR can be merged. The plan step appends an <em>AI Hub Infra Changes</em> section to the PR description with a readable plan summary; when there are no infra diffs the section says <code>No Changes to AI Hub Infra in this PR</code>.</div>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>schedule.yml (Scheduled Cleanup)</h2>

<p>Automatically destroys Bastion every day at 5 PM PST to prevent unnecessary charges.</p>

<div class="card">
    <h3>Schedule</h3>
    <pre># Runs daily at 5 PM PST (1 AM UTC next day)
on:
  schedule:
    - cron: "0 1 * * *"</pre>
</div>

<div class="card card-gold">
    <h3>Workflow Logic</h3>
    <ol>
        <li><strong>Check if Bastion exists</strong>: Uses Azure CLI to query the Bastion resource</li>
        <li><strong>Conditional destroy</strong>: Only runs Terraform destroy if Bastion is found</li>
        <li><strong>Status notification</strong>: Reports whether Bastion was destroyed or already removed</li>
    </ol>
</div>

<h3>Jobs Flow</h3>

<pre>check-and-destroy-bastion
         │
         ├── bastion_exists=true ──► destroy-bastion ──► notification
         │
         └── bastion_exists=false ──────────────────────► notification</pre>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>manual-dispatch.yml (Manual Promotion Workflow)</h2>

<p>Use this workflow to run <code>plan</code>, <code>apply</code>, or <code>destroy</code> for <code>dev</code>, <code>test</code>, and <code>prod</code>.</p>

<div class="card">
    <h3>How It Works</h3>
    <ol>
        <li>Validates inputs — <strong>prod apply requires a <code>deploy_tag</code></strong> (a semver tag like <code>v1.2.3</code> from a successful <code>merge-main.yml</code> run)</li>
        <li>Deploys/refreshes <code>azure_proxy</code> in <code>tools</code> via <code>.deployer.yml</code></li>
        <li>Passes encrypted proxy outputs to <code>.deployer-using-secure-tunnel.yml</code></li>
        <li>Executes selected Terraform command in chosen environment</li>
        <li><strong>For prod apply only</strong>: Creates a GitHub Release from the deployed tag with deployment metadata</li>
    </ol>
</div>

<div class="alert alert-warning">
    <div><strong>PROD is gated:</strong> The <code>prod</code> environment has <strong>required reviewers</strong> configured as a GitHub Environment protection rule. Any workflow job targeting <code>prod</code> will pause and wait for manual approval from designated reviewers before executing. Additionally, <code>prod apply</code> requires you to specify which semver git tag to deploy — ensuring only test-validated commits reach production.</div>
</div>

<div class="alert alert-info">
    <div><strong>Dev Environment Scope:</strong> Developers may occasionally deploy to <code>dev</code> from a PR branch using workflow dispatch to test specific features. The <code>dev</code> environment does <strong>not</strong> include App Gateway or DNS Zone; end-to-end ingress and DNS validation is only supported in <code>test</code> and <code>prod</code>.</div>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>merge-main.yml (Auto Apply + Semantic Version on Main)</h2>

<p>This workflow runs on every push to <code>main</code>. It creates a semantic version tag using <a href="https://www.conventionalcommits.org/en/v1.0.0/">Conventional Commits</a> and then applies infrastructure to <code>test</code>.</p>

<div class="card">
    <h3>Execution Flow</h3>
    <ol>
        <li><strong>Concurrently on push to main</strong>:
            <ul>
                <li><strong>Semantic version</strong>: <code>TriPSs/conventional-changelog-action</code> inspects commits since last tag (<code>feat:</code> → minor, <code>fix:</code> → patch, <code>BREAKING CHANGE</code> → major), creates a git tag (e.g. <code>v1.2.3</code>), and pushes an updated <code>CHANGELOG.md</code></li>
                <li><strong>Proxy bootstrap</strong>: deploys/refreshes <code>azure_proxy</code> in <code>tools</code> via <code>.deployer.yml</code></li>
            </ul>
        </li>
        <li>Once <code>azure_proxy</code> is live, its encrypted URL+auth outputs are passed to <code>.deployer-using-secure-tunnel.yml</code></li>
        <li>Run <code>apply</code> against <code>test</code> (through Chisel tunnel)</li>
        <li>After successful apply, integration tests run automatically in two phases (direct + via proxy — see <code>.deployer-using-secure-tunnel.yml</code> section)</li>
    </ol>
</div>

<div class="alert alert-info">
    <div><strong>Why semver tags?</strong> Semantic version tags serve as the input for prod deployments. When promoting to prod via <code>manual-dispatch.yml</code>, you provide a version tag (e.g. <code>v1.2.3</code>) to ensure the exact commit that passed test is what gets applied to production. The version is derived from commit messages, so <code>feat:</code> and <code>fix:</code> prefixes directly control versioning.</div>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>Release Process (TEST → PROD)</h2>

<p>Production releases follow a tag-based promotion flow:</p>

<div class="card card-gold">
    <h3>Steps to Release to Production</h3>
    <ol>
        <li>Merge your PR to <code>main</code> — the test deployment and semantic versioning run automatically</li>
        <li>Verify the test deployment succeeded and a version tag was created (visible in Actions summary and repo tags, e.g. <code>v1.2.3</code>)</li>
        <li>Go to <strong>Actions → Deploy to Environments (Manual Dispatch)</strong></li>
        <li>Select: <code>environment=prod</code>, <code>command=apply</code>, <code>deploy_tag=v1.2.3</code></li>
        <li>Click <strong>Run workflow</strong> — the job will pause waiting for <strong>prod environment approval</strong></li>
        <li>A designated reviewer approves the deployment in the Actions UI</li>
        <li>After successful apply, a <strong>GitHub Release</strong> is automatically created with deployment details</li>
    </ol>
</div>

<div class="card">
    <h3>Release Contents</h3>
    <p>Each GitHub Release created for prod includes:</p>
    <ul>
        <li>The git tag that was deployed</li>
        <li>Commit SHA</li>
        <li>Who triggered the deployment</li>
        <li>Link to the workflow run</li>
        <li>Timestamp</li>
    </ul>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>Concurrency Strategy</h2>

<p>Several workflows and reusable jobs use <code>concurrency</code> to prevent race conditions and conflicting Terraform operations.</p>

<table>
    <thead>
        <tr>
            <th>Workflow/Job</th>
            <th>Concurrency Group</th>
            <th>Why It Helps</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>.deployer.yml</code></td>
            <td><code>tools</code></td>
            <td>Serializes tools/bootstrap changes so multiple runs don't mutate shared proxy infra at the same time.</td>
        </tr>
        <tr>
            <td><code>.deployer-using-secure-tunnel.yml</code></td>
            <td><code>${environment_name}</code></td>
            <td>Ensures only one Terraform operation per environment runs at once (for example, only one test apply).</td>
        </tr>
        <tr>
            <td><code>pr-open.yml</code> builds job</td>
            <td><code>builds-${PR number}</code> (cancel in-progress)</td>
            <td>Stops stale image builds when a newer commit arrives in the same PR.</td>
        </tr>
        <tr>
            <td><code>manual-dispatch.yml</code></td>
            <td><code>manual-deploy-${run_id}</code></td>
            <td>Keeps each manually triggered deployment isolated and traceable to a single run.</td>
        </tr>
        <tr>
            <td><code>merge-main.yml</code></td>
            <td><code>deploy-test-on-main</code></td>
            <td>Queues merges to main so test applies execute in order and avoid state lock contention.</td>
        </tr>
    </tbody>
</table>

<div class="alert alert-info">
    <div><strong>Practical Effect:</strong> Concurrency improves deployment reliability by reducing Terraform state lock failures, avoiding overlapping applies, and ensuring each environment converges predictably.</div>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>apim-key-rotation.yml (Scheduled + Manual)</h2>

<p>Rotates APIM subscription keys using OIDC-authenticated Azure CLI execution.</p>

<div class="grid grid-2">
    <div class="card">
        <h3>Manual Mode</h3>
        <ul>
            <li>Trigger with <code>workflow_dispatch</code></li>
            <li>Select environment: <code>dev</code>, <code>test</code>, <code>prod</code></li>
            <li>Optional <code>dry_run=true</code> for safe preview</li>
        </ul>
    </div>
    <div class="card card-gold">
        <h3>Scheduled Mode</h3>
        <ul>
            <li>Runs daily at <code>0 9 * * *</code> UTC (1–2 AM Pacific, depending on DST)</li>
            <li><code>rotate-dev</code> and <code>rotate-test</code> run <strong>concurrently</strong> (no dependency between them)</li>
            <li><code>rotate-prod</code> has <code>needs: [rotate-test]</code> — waits for test to succeed first</li>
            <li>A <code>notify</code> job (<code>if: always()</code>) prints a per-environment result summary</li>
        </ul>
    </div>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>pages.yml (Documentation)</h2>

<p>Deploys this documentation site to GitHub Pages when changes are pushed to docs or Terraform roots (so generated references stay current).</p>

<div class="card">
    <h3>Triggers</h3>
    <ul>
        <li><strong>Push to main</strong>: When files in <code>docs/**</code>, <code>initial-setup/infra/**</code>, or <code>infra-ai-hub/**</code> change</li>
        <li><strong>Manual</strong>: Can be triggered manually via <code>workflow_dispatch</code></li>
    </ul>
</div>

<div class="card">
    <h3>Deployment Steps</h3>
    <ol>
        <li>Checkout repository</li>
        <li>Run <code>docs/generate-tf-docs.sh</code> to refresh Terraform reference content</li>
        <li>Run <code>docs/build.sh</code> to generate HTML from templates</li>
        <li>Configure GitHub Pages</li>
        <li>Upload <code>docs/</code> folder as artifact</li>
        <li>Deploy to GitHub Pages</li>
    </ol>
</div>

<hr style="margin: 2rem 0; border: none; border-top: 1px solid #e2e8f0;">

<h2>Environment Secrets</h2>

<p>Each GitHub environment requires these secrets (created by <code>initial-azure-setup.sh</code>):</p>

<table>
    <thead>
        <tr>
            <th>Secret</th>
            <th>Description</th>
            <th>Source</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><code>AZURE_CLIENT_ID</code></td>
            <td>Managed Identity client ID</td>
            <td>Created by setup script</td>
        </tr>
        <tr>
            <td><code>AZURE_TENANT_ID</code></td>
            <td>Azure AD tenant ID</td>
            <td>Your Azure subscription</td>
        </tr>
        <tr>
            <td><code>AZURE_SUBSCRIPTION_ID</code></td>
            <td>Target subscription ID</td>
            <td>Your Azure subscription</td>
        </tr>
        <tr>
            <td><code>VNET_RESOURCE_GROUP_NAME</code></td>
            <td>Resource group containing VNet</td>
            <td>Your infrastructure</td>
        </tr>
        <tr>
            <td><code>VNET_NAME</code></td>
            <td>Existing VNet name</td>
            <td>Your infrastructure</td>
        </tr>
        <tr>
            <td><code>VNET_ADDRESS_SPACE</code></td>
            <td>VNet CIDR block</td>
            <td>Your infrastructure</td>
        </tr>
    </tbody>
</table>

<h2>Running Workflows Locally</h2>

<p>For local development and testing, use the deployment scripts in each Terraform root:</p>

<pre># Ensure you're logged in
az login

# Initial setup / tools
./initial-setup/infra/deploy-terraform.sh init
./initial-setup/infra/deploy-terraform.sh plan
./initial-setup/infra/deploy-terraform.sh apply</pre>

<pre># AI Hub stacks
./infra-ai-hub/scripts/deploy-terraform.sh plan dev
./infra-ai-hub/scripts/deploy-terraform.sh apply test</pre>

<div class="alert alert-info">
    <div><strong>Note:</strong> Local runs use your Azure CLI credentials instead of OIDC. Make sure you have the required permissions.</div>
</div>
